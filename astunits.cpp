#include "astunits.h"

extern symboltable symtab;
extern memallocator alloc;
extern typelibrary typelib;

//
//
//////////////////// subclassdefine 
//
//
void subclassdefine::debug(int ind)
{
	cout << indent(ind) << "subclassdefine" << endl;
	thisclass->debug(ind + 1);
	superclass->debug(ind + 1);
}
void subclassdefine::createTypes()
{
	string thisclassname = symtab.idlookup(thisclass->getSymbolid())->name;
	string superclassname = symtab.idlookup(superclass->getSymbolid())->name;
	type* thistype = typelib.getOrCreateType(thisclassname);
	type* supertype = typelib.getOrCreateType(superclassname);
	if (thistype->superclass) {
		cout << " superclass defined twice for " << thisclassname << endl;
		exit(1);
	}
	thistype->superclass = supertype;
}
subclassdefine::~subclassdefine()
{
	delete thisclass;
	delete superclass;
}


//
//
//////////////////// propertydefine 
//
//
void propertydefine::debug(int ind)
{
	cout << indent(ind) << "property define (" + symtab.idlookup(propid)->name + ")" << endl;
	obj->debug(ind + 1);
	proptype->debug(ind + 1);
}

void propertydefine::createTypes()
{
	string objname = symtab.idlookup(obj->getSymbolid())->name;
	string proptypename = symtab.idlookup(proptype->getSymbolid())->name;
	string propname = symtab.idlookup(propid)->name;
	type* objtype = typelib.getOrCreateType(objname);
	type* proptype = typelib.getOrCreateType(proptypename);
	property* p = objtype->getPropertyByName(propname);
	if (p) {
		cout << "property defined twice for " << propname << endl;
		exit(1);
	}
	p = new property(propname, proptype);
	objtype->addProperty(p);
	objtype->size++;
}

propertydefine::~propertydefine()
{
	delete obj;
	delete proptype;
}


//
//
//////////////////// proceduredeclare 
//
//
void proceduredeclare::debug(int ind)
{
	cout << indent(ind) << "procedure declare (" + symtab.idlookup(procname)->name + ")" << endl;
	thisclass->debug(ind + 1);
	params->debug(ind + 1);
}
void proceduredeclare::createTypes()
{
	string thisclassname = symtab.idlookup(thisclass->getSymbolid())->name;
	string procnamestr = symtab.idlookup(procname)->name;
	vector<type*> paramtypes = params->getTypes();
	type* objtype = typelib.getOrCreateType(thisclassname);
	// check for doubly-defined methods
	// method overloading not yet supported
	if (objtype->getMethodByName(procnamestr)) {
		cout << "method defined twice for " << procnamestr << endl;
		exit(1);
	}
	// return type is none, so pass 0
	method* m = new method(procnamestr, 0, paramtypes);
	objtype->addMethod(m);
}
proceduredeclare::~proceduredeclare()
{
	delete thisclass;
	delete params;
}

//
//
//////////////////// functiondeclare 
//
//
void functiondeclare::debug(int ind)
{
	cout << indent(ind) << "function declare" << endl;
	funcname->debug(ind + 1);
	classname->debug(ind + 1);
	params->debug(ind + 1);
	returntype->debug(ind + 1);
}
void functiondeclare::createTypes()
{
	string thisclassname = symtab.idlookup(classname->getSymbolid())->name;
	string procnamestr = symtab.idlookup(funcname->getSymbolid())->name;
	string returntypename = symtab.idlookup(returntype->getSymbolid())->name;
	vector<type*> paramtypes = params->getTypes();
	type* objtype = typelib.getOrCreateType(thisclassname);
	// check for doubly-defined methods
	// method overloading not yet supported
	if (objtype->getMethodByName(procnamestr)) {
		cout << "method defined twice for " << procnamestr << endl;
		exit(1);
	}
	type* rtype = typelib.getOrCreateType(returntypename);
	method* m = new method(procnamestr, rtype, paramtypes);
	objtype->addMethod(m);
}
functiondeclare::~functiondeclare()
{
	delete funcname;
	delete classname;
	delete params;
	delete returntype;
}



//
//
//
////////////////// functionunit
//
//
//
//
registerid functionunit::generateCode(operation* &unused)
{
	// the semantic check will establish the method pointer.

	// functions get a start operation.  Ignore p.
	// the start operation may have already been generated by a call to this.
	alloc.reset();
	symtab.resetScope();
	operation* entrypoint = mymethod->code;
	operation* p = entrypoint;
//	entrypoint->setDebugText(se->name);
	if (preps) {
		preps->generateCode(p);
	}
	statements->generateCode(p);
	cout << "not yet implemented: return code for procedures?" << endl;
	exit(1);
	/*
	if (ftype == FTYPE_PROCEDURE) {
		// procedures do not have return statements but we still have to put this in.

		registerid jumpto = alloc.getNextRegister();
		entrypoint = entrypoint->append(new op_pop(jumpto));
		entrypoint = entrypoint->append(new op_push((registerid)0)); // return value of NULL
		entrypoint = entrypoint->append(new op_jumpreg(jumpto));

		//operation* ret = new op_return();
		//entrypoint->append(ret);
	}
	*/
	mymethod->code = entrypoint;
	return -1;
}

/*
 *
		registerid generateCode(operation* &p);

		alloc.reset();
		symtab.resetScope();
		unit* u = defs.getCurrent();
		operation* z;
		u->generateCode(z);
		type* gtype = typelib.getTypeByName("##global");
		method* m = new method(u->getName(), z, 0, vector<type*>());
		gtype->addMethod(m);
 */


functionunit::~functionunit()
{
	delete statements;
	if (preps) delete preps;
}




//
//
//
////////////////// run
//
//
//
void run::debug(int ind)
{
	cout << indent(ind) << "run" << endl;
	statements->debug(ind + 1);
}
void run::createTypes()
{
	type* t = typelib.getOrCreateType("##global");
	vector<type*> p; // empty vector of parameters
	if (t->getMethodByName("run")) {
		cout << "error: run method defined twice." << endl;
		exit(1);
	}
	mymethod = new method("run", 0, p);
	t->addMethod(mymethod);
}

//
//
//
////////////////// proceduredefine
//
//
//
void proceduredefine::debug(int ind)
{
	cout << indent(ind) << "proceduredefine (name=" + symtab.idlookup(name)->name + ")" << endl;
	obj->debug(ind + 1);
	preps->debug(ind + 1);
	statements->debug(ind + 1);

}
void proceduredefine::createTypes()
{
	symbolid objname = obj->getSymbolid();
	string nm = symtab.idlookup(objname)->name;

	type* thistype = typelib.getOrCreateType(nm);
	method* m;
	if (!(m = thistype->getMethodByName(nm))) {
		cout << "error: " << nm << " tried to define an undeclared procedure." << endl;
		exit(1);
	}
	mymethod = m;
}
proceduredefine::~proceduredefine()
{
	delete obj;
}

//
//
//
////////////////// methoddefineunit
//
//
//

void methoddefineunit::debug(int ind)
{
	cout << indent(ind) << "methoddefineunit" << endl;
	name->debug(ind + 1);
	obj->debug(ind + 1);
	preps->debug(ind + 1);
	statements->debug(ind + 1);
}

void methoddefineunit::createTypes()
{
	symbolid objname = obj->getSymbolid();
	string nm = symtab.idlookup(objname)->name;

	type* thistype = typelib.getOrCreateType(nm);
	method* m;
	if (!(m = thistype->getMethodByName(nm))) {
		cout << "error: " << nm << " tried to define an undeclared procedure." << endl;
		exit(1);
	}
	mymethod = m;
}

methoddefineunit::~methoddefineunit()
{
	delete name;
	delete obj;
}

//
//
//
//////////////////constructordefine  
//
//
//
void constructordefine::debug(int ind)
{
	cout << indent(ind) << "constructordefine" << endl;
	obj->debug(ind + 1);
	preps->debug(ind + 1);
	statements->debug(ind + 1);
}
void constructordefine::createTypes()
{
	symbolid objname = obj->getSymbolid();
	string nm = symtab.idlookup(objname)->name;

	type* thistype = typelib.getOrCreateType(nm);
	method* m;
	if (!(m = thistype->getMethodByName(nm))) {
		cout << "error: " << nm << " tried to define an undeclared procedure." << endl;
		exit(1);
	}
	mymethod = m;
}
constructordefine::~constructordefine()
{
	delete obj;
}














































/*

void function::debug(int ind)
{ 
	if (ftype == FTYPE_PROCEDURE) {
		cout << indent(ind) << "procedure (" << symtab.idlookup(classname)->name << "." << symtab.idlookup(name)->name << ")" << endl;
	} else if (ftype == FTYPE_CONSTRUCTOR) {
		cout << indent(ind) << "constructor" << endl;
	} else if (ftype == FTYPE_RUN) {
		cout << indent(ind) << "run function" << endl;
	} else if (ftype == FTYPE_GETTER) {
		cout << indent(ind) << "getter (" << symtab.idlookup(classname)->name << "." << symtab.idlookup(name)->name << ")" << endl;
	} else if (ftype == FTYPE_SETTER) {
		cout << indent(ind) << "setter (" << symtab.idlookup(classname)->name << "." << symtab.idlookup(name)->name << ")" << endl;
	} else {
		cout << indent(ind) << "unknown function type" << endl;
	}
	if (args) {
		args->debug(ind + 1);
	}
	code->debug(ind + 1);
}

void function::semanticCheck() 
{
	code->semanticCheck();
	if (ftype == FTYPE_GETTER) {
		// check to see whether there is a return statement
		// error if not
	}
}

string function::getName()
{
	return symtab.idlookup(name)->name;
}

//if we want to allow people to call functions before they are defined
//we need to introduce an additional pass.
//C doesn't allow this but most other languages do.
//java:
//class foo
//{
//	int doit()
//	{
//		return reallydoit();
//	}
//	int reallydoit()
//	{
//		return 4;
//	}
//}
//so we need to have a first pass that establishes the type tree
//before we generate the code.
registerid function::generateCode(operation* &p)
{
	// we need to store the code in the type tree, not in the symbol table.
	cout << "NOT YET IMPLEMENTED: function::generateCode (1)" << endl;
	exit(1);

//	// functions get a start operation.  Ignore p.
//	// the start operation may have already been generated by a call to this.
//	symtableentry* se = symtab.idlookup(name);
//	operation* entrypoint = se->code;
//	if (entrypoint == 0) {
//		entrypoint = new op_start();
//		se->code = entrypoint;
//	}
//	entrypoint->setDebugText(se->name);
//	operation* r = entrypoint;
//	code->generateCode(entrypoint);
//	if (ftype == FTYPE_PROCEDURE) {
//		// procedures do not have return statements but we still have to put this in.
//
//		registerid jumpto = alloc.getNextRegister();
//		entrypoint = entrypoint->append(new op_pop(jumpto));
//		entrypoint = entrypoint->append(new op_push((registerid)0)); // return value of NULL
//		entrypoint = entrypoint->append(new op_jumpreg(jumpto));
//
//		//operation* ret = new op_return();
//		//entrypoint->append(ret);
//	}
//	p = r;
//	
	return -1;
}

function::~function()
{
	delete args;
	delete code;
}
*/
